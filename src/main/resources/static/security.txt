Security

https://velog.io/@chickenrun/%EC%84%B8%EC%85%98-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D-VS-Token-%EC%9D%B8%EC%A6%9D%EB%B0%A9%EC%8B%9D%EC%9D%B8%EC%A6%9D%EA%B3%BC-%EC%9D%B8%EA%B0%80

* 무상태성(stateless) : 클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존하지 않음

-> 서버에서 클라이언트가 누군지 아는 상태에서 클라이언트가 명령을 바꾸면 바뀐 명령을 수행
=> 무상태성 : 바꾸기 전의 명령과 그 이후의 명령 둘 다 수행 (클라이언트의 정보를 기억하지 않기 때문에)

* 인증 vs 인가

* 인증(Authentication) : 유저가 누구인지 확인하는 절차
   -> ex) 회원가입, 로그인

* 인가(Authorization) : 유저의 요청에 대한 권한을 확인하고 허가해주는 것
   -> ex) 놀이공원에서 입장팔찌를 받고 나서의 행동들

1. 세션 인증 방식

- 세션기반 인증을 하기 위해서는 Session과 Cookie가 사용된다

* Cookie : 브라우저에 사용되는 정보 -> 세션 인증을 하는 데 사용됨
* Session : 서버에 저장되는 사용자 정보
-> F12 -> Application -> Cookies -> JSessionID
-> JSESSIONID : 서버가 사용자를 구분하기 위해 발급하는 세션 식별 번호
   => (각각의 클라이언트들을 구분하기 위한 사물함 번호)

* 세션 인증 방식 :

- 최초 요청 때 한 번 응답으로 세션ID를 쿠키 응답으로 들고 감.
-> 요청을 날릴 수 있는 프로세서들 마다 세션ID가 부여됨.

-> 크롬에서 처음 로그인을 하고 새 탭을 들어가면 다시 로그인 할 필요 x
   -> 같은 프로세서이기 때문에 인증이 이미 되서 인가만 하면 됨

-> 크롬에서 처음 로그인을 하고 엣지로 들어가면 다시 로그인을 해야됨
   -> 클라이언트가 달라서 인증되었는지 확인이 안되었기 때문에.

=> 브라우저들 마다 세션ID가 주어지며, 브라우저를 종료시킨 후 다시 요청을 날리면 완전히 새로운 요청이 됨 -> 새 쿠키가 생김

* 세션 인증 방식의 문제
브라우저를 계속 껐다가 키면서 무분별하게 요청을 날림
-> 서버가 각각의 클라이언트의 개수만큼 세션ID(인증되었다는 정보)를 다 저장해야됨
-> 용량 낭비

=> 세션을 쓸 때 중요한 것 : 만료 시간

- 기본 만료시간 : 20 ~ 30분


2. 토큰 인증 방식

로그인하면 서버가 사용자 정보를 담은 토큰(JWT 등) 을 클라이언트에게 줌.

이후 클라이언트는 요청할 때마다 토큰을 헤더에 넣어 전송.

서버는 토큰을 검증만 하고, 별도로 사용자 상태를 저장하지 않음.

* 특징

Stateless(무상태) → 서버가 로그인 상태를 기억할 필요 없음

확장 쉬움 → 여러 서버에서 동일하게 인증 가능

쿠키 필요 없음 → 모바일/앱/프론트 간 통신에 유리

보안은 토큰 자체에 서명 포함 → 위·변조 방지

* 한 줄 요약

토큰 인증 = 로그인 정보를 담은 토큰을 클라이언트가 직접 들고 다니며 인증하는 방식. (서버는 상태를 저장하지 않음)


서버가 토큰을 주면 클라이언트가 어디에 가지고 있을건가 ? => 여러가지 방법이 존재

1. 리액트 자체의 전역상태에 보관
-> 새로고침을 하지 않는 한 첫 렌더링 이후 계속 유지

2. key -value형식으로 따로 저장

3. 쿠키에다 key - value 형식으로 저장
-> 쿠키의 유지시간을 정할 수 있다.
-> 토큰 자체에도 유효시간이 있는데, 이걸 지정해줄 수 있다.

-----------------------------------------------------------------

순서
서버 -> 처음으로 사이트에 들어왔으면 회원가입 하기
회원가입 -> 로그인할 정보를 제공하는 것
요청을 날려야 함  -> 인증이 필요 없음 -> 필터를 타면 안됨.
-> 이 필터는 인증이 필요할 때만 타는 필터
permitAll() : 인가 -> 회원가입 URL이 있어야 통과시킴
회원가입을 하면 DB에 데이터가 저장됨
->로그인
-> ID, PW를 입력한 다음 이전에 알려준 정보와 일치하면(인증)
-> 인증 요청을 날림
-> 서버 측에서는 ID, PW 맞는지 확인한 다음에
-> 응답으로 토큰을 발행해 줌
-> 클라이언트는 토큰을 가지고 있고, 이 클라이언트의 토큰을 이후의 다른 요청에 사용
-> 로그인할 때 인증이 되어있어야 하나? --> NO
=> 로그인 요청도 permitAll();
--> 데이터를 요청할 경우 인가가 필요
-> 인증 이후의 받은 토큰을 가지고 인가를 받아야 함.
->회원가입, 로그인 외의 나머지 다른 모든 요청들은 인가받아야함.